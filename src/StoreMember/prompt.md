1. Основные принципы архитектуры

Децентрализованная сеть:

    Каждый узел (хранилище) полностью автономен
    Все узлы равноправны в сети
    Нет выделенного сервера или координатора
    Сетевая топология организована как полносвязный граф

Событийная модель:

    Все изменения данных передаются через события
    Обработка событий происходит асинхронно
    События имеют строгую типизацию для валидации
    Каждое событие содержит метаданные для правильной маршрутизации

2. Версионирование данных

Детерминированное хеширование:

    Версии объектов вычисляются детерминированно
    Первая версия: hash(key + dataHash + timestamp)
    Последующие версии: hash(oldVersion + newDataHash)
    Для разрешения коллизий используется уникальный алгоритм

История версий:

    Хранится история изменений для каждого объекта
    Версии формируют цепочку зависимостей
    Позволяет отслеживать происхождение изменений
    Обеспечивает возможность отката к предыдущим состояниям

3. Разрешение конфликтов

Сценарий возникновения конфликтов:

    Два узла независимо изменяют один и тот же объект
    Оба узла рассчитывают разные версии для одного объекта
    При синхронизации обнаруживается несовпадение версий

Алгоритм разрешения:

    При обнаружении конфликта первый узел:
        Переименовывает свою версию объекта
        Вычисляет новый ключ как комбинацию половин хэшей
        Отправляет событие конфликта в сеть
    Другие узлы при получении события:
        Аналогично переименовывают свои версии
        Не отправляют дополнительные события (предотвращение циклов)
    Результат:
        Оригинальный объект заменяется двумя новыми
        Каждый узел сохраняет свою версию данных
        Конфликт разрешается децентрализованно

Генерация новых ключей:

    Новые ключи имеют фиксированную длину
    Формируются как: половина_хэша(originalKey) + половина_хэша(localVersion)
    Гарантирует уникальность без нарастания длины при повторных коллизиях
    Сохраняет детерминированность - все узлы вычислят одинаковые ключи

4. Фильтрация событий

По типу хранилища (namespace):

    Каждое хранилище имеет определенный тип (namespace)
    События от хранилищ другого типа игнорируются
    Обеспечивает изоляцию разных типов данных
    Позволяет одновременно работать с несколькими типами хранилищ

По источнику события:

    Хранилище игнорирует свои собственные события
    Используется UUID хранилища для идентификации
    Предотвращает зацикливание обработки событий
    Упрощает логику синхронизации

5. Обработка удаленных объектов

Мягкое удаление (toTrush):

    Объекты не удаляются физически сразу
    Помечаются как удаленные в специальной коллекции
    Локально игнорируются при операциях с данными
    Другие узлы получают уведомление об удалении

Восстановление объектов:

    Если приходит обновление для удаленного объекта
    Флаг удаления автоматически снимается
    Объект восстанавливается с новой версией
    Обеспечивает согласованность при расхождении мнений об удалении

6. Преобразование данных

Автоматическая сериализация:

    Поддержка любых типов JavaScript
    Автоматическое преобразование в Uint8Array
    Специальная обработка для разных типов данных:
        Строки кодируются в UTF-8
        Числа сохраняются как Float64
        Объекты сериализуются в JSON
        Бинарные данные обрабатываются напрямую

Ограничение размера:

    Максимальный размер объекта - 64KB
    Проверка размера выполняется на всех этапах
    Четкие ошибки при превышении лимита
    Готовность к расширению для больших объектов

7. Состояния хранилища

Три состояния синхронизации:

    empty - хранилище не содержит данных
    not_synced - есть данные, но нет полной синхронизации
    synced - все данные синхронизированы с сетью

Автоматический переход между состояниями:

    При создании первого объекта: empty → not_synced
    При достижении полной синхронизации: not_synced → synced
    При рассогласовании данных: synced → not_synced
    Состояния влияют на поведение при синхронизации

8. Производительность и масштабируемость

Оптимизация памяти:

    Хранение хэшей данных отдельно от самих данных
    Быстрое сравнение версий без полного пересчета
    Минимизация копирования данных при операциях

Обработка коллизий:

    Линейная сложность разрешения конфликтов
    Фиксированная длина ключей предотвращает деградацию
    Асинхронная обработка событий для предотвращения блокировок

Готовность к масштабированию:

    Поддержка тысяч объектов в хранилище
    Эффективная работа с несколькими узлами в сети
    Возможность расширения для партиционирования данных
    Подготовка к добавлению индексов для быстрого поиска

Эта архитектура обеспечивает надежную, детерминированную и эффективную синхронизацию данных в распределенной среде, сохраняя при этом простоту использования и гибкость для дальнейшего развития.