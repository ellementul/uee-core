# Storage Member

## Ключевые понятия

### Элемент данных
Элемент данных это самостоятельная цельная единица данных которая может быть файлом или просто каким то объектом для хранения.
Элемент данных имеет уникальный id и хэш данных, а так же версию в заголовках(метаданных)
Первая версия элемента получается путем вызова фукнции хэширования от id и хэша данных.
КаждаЯ последующая получается путем вызова фукнции хэширования от предидущей версии и нового хэша данных.

```js
const firstVersion = hash(id + dataHash)
const nextVersion = hash(firstVersion + newDataHash)
```

Такой версионирование позволяет отслеживать является ли вверстя эдемента данных что пришел от другого хранилища следующей версией, текущей, или предидущей,и на основе этого обновлять данные.

Так метаданные элемента содержат суммарный рамер данных, и ссылки на связаные с ним элементы от которых он зависит, или которые зависят от него.

### Коллизия элементов
Если два элемента имееют одинаковый идентификатор, но по версии не являются совместимыми, то генерируется событие колизиии.
СТандартным повдением является удаление обоих элементов и создание двух новых, индификаторами(id) которых станет их старый идетификатор плюс потсфикс в виде первого байта несвопадающего в строках версий.

Таким образом они будут иметь сатрый идетфикатор как часть нового, плюс байт который точно разный у них в версиях.

### Дерево хэширования
Это дерево в котором элементы(их метаданные) данных являются листьями, а хэш всех элементов это корень дерева и хэш самого хранилища
Каждый узел дерева это содержит хэш некоторго поддерева со всеми элементами-листьями

Два таких дерева можно сравнивать начиная от корня и спускаясь к листьям, чтобы быстро найти все элементы которые различаются между этими деревьями.
Новые элементы распределяются между узлами рандомно

### Хранилище
Содержит данные, имеет разный статус согласования с другими хранилищами в сети
Так же имеет дерево элементов, чтобы быстро и эффективно находить разницу в данных с другими хранилищами
После каждого обновления данных дерево хэширования обновляется.
Дерево находится в оперативной памяти
Сами данные хранятся отдельно по своему идентификатору так же в опертаивной памяти или даже в файловой системе.

### Пустое хранилище
Это хранилище не имеет еще никаких данных, все пустые хранилища имеют один и тот же хэш

### Сообщение
Это пакет данных посылаемых хранилищем и позволяющий обмениваться событиями в сети
Эти данные являются обязательными для любого обмена 
- uuid - идентификатор хранилища
- status - статус хранилища
- hash - хэш данных этого хранилища

### Хранилище-Источник
Если считать разные хранилища множествами в математическом смысле, а элементы данных элементами этих множеств, то истоник гарантировано содержит пересечение более половины хранилищ(то есть данные которые есть более чем в половине хранилище) кроме тех кто подключился уже после того как хранилище получило статус Источника. Таким образом данные полученые уже после получения статуса Источника не учитываются.

### Сеть хранилищ
Состоит из хранилищ связанных между собой
Любое сообщение от одного из хранилищ получают все
Каждое хранилище имеет у себя список всех хранилищ в сети и их статусов синхронизации
Этот список обновляется получением сообщений от друг друга 

Если хранилище не отправляло никаких событий от себя в течении секунды, то оно детает специальный пинг чтобы подтвердить статус сети.

Если в сети есть источники, то статус сети считается синхронизированным.
Источники в сети формируют некторое согласованное большинство хранилищ, источников может быть менее чем половины всех хранилищ, но при этом из согласованных между собой хранилищ они большинство.
При этом источники могут иметь немного разные данные которые получены за последние 5 секунд, потому не все новые данные были ими получены от друг друга. Главное что более половины из них, имели одинаковый набор данных за последние 5 секунд.

Только Источники могут добавлять новые данные в сеть
Если в сети нет ни одного хранидища со статусом источника, то сеть находится в рассинхронизированом состоянии, и все хранилища должны перейти в статус встречной синхронизации.

### Встречаная синхронизация
Хранилища соревнуются в поиске данных которые отличают их от других.
Они не пересылают сами данные, а только заголовки друг другу, а в ответ помечают есть ли у них такие данные или нет
Если у хранилища есть данные которых нет у кого то еще, то такие данные убираются в очередь для будущего добавления.
Хранилище которое первым подтвердит что все данные которые у него есть, есть и остальных, становится Источником.
При этом конечно другие хранилища тоже могут стать источником

Eсли данных нет в Источнике, но при этом оно есть в каком то хранилище, то хранилище которое их имеет обязано раздать эти данные всем, после того как оно станет Источником.

#### Важное замечание что пустое хралище не может стать источником если в сети есть хоть одно не пустое хранилище
И таким образом при встречной синхронизации, пустой хранилище не переходит в статус источника, и не отвечает на события встречной синхронизации, если етсь непустые хранилища в сети. Если же все хранилища пустые, то они все автоматом становятся источниками
Непустые хранилища не ждут и не учитывают ответы пустых хранилищ в своей синхронизации

### Синхронизация с источниками
Хранилиза не персылают сами данные, а только их заголовки
Хранилище видя что в сети есть источники, начичнает проверять какие данные у него из источников уже есть, а каких нет.
Все данные которые есть у хранилища, но нет в Источниках, убиратся в очередь на добавления когда статус Источника будет получен.
Так же все новые данные не от Источников, например от пользователя, так же ставятся в очередь на добавление.

### Поддержание синхронизации между источниками
Источник хранит ограниченую историю хэшей для всех других хранилищ в сети
Хэши сортируются в истории в порядки их получения.
Так как история ограничена то более новые хэши вытесняют старые хэши из истории для хранилища

Если хранилище не источник, то будет хранится только один хэш
Если другое хранилище является источником, то хэши котроые пришли от него записываются в историю для этого источника в текущем хранилище.

Сравнение хэшей двух хранилищ это сравнение двух историй хранилищ, текщего и какого другого. если в них есть хотя бы один общий хэш, значит как миниум один раз эти хранилищи имели одинаковый набор данных. Это считается что они синхронизировались.
Более свежие совпадения должны находтся первыми в историях. При одном достаточно одного совпадения между двумя историями

Если совпадение в истории двух хранилищ найдены, то делатеся отметка чтобы найдена синхронизация между этми двумяф хранилищами.
При этом история текущего хранилища никак не меняется, а история для другого хранилища которая хранится в текущем хранилище очищается до совпадающего хэша(включая этот хэш), все что более новое чем совпадающий хэш сохраняется. Таким образом новая синхронизация не будет пока в истории не появится новое совпадение.

Этот механизм позволяет не сравнивать два хэша в моменте, потому они могут быть не равны если новые данные были получины одим источником, но не получены еще другим, но сранивать истории двух хранилищ, которые покажут что в какой то момент времени оба хранилища имели

Каждые 5 секунд, проверятся список источников, отметки синхронизации в нем.
При стабильной синхронизации большинство источников должны быть отмечены синхронизированными в списке.
Большинство здесь считается половиной всего количества с округлением вверх.
Отметки в списке очищаются.
Так же очищается история текущего хранилища которая хранится в текущем хранилище
Если оказывается что большинство истоников не были синхронизированы, то текущее хранилище теряет статус источника и обьявляет об этом событии.

Остальные источники получая это событие, исключат его из своих списоков источников.
Такая деградация моджет проиходить пока источников не останется двое в сети
Если истчоников в сети двое, то любая рассинхронизация между ними приводит к переходу всех в режим встречной синхронизации.
